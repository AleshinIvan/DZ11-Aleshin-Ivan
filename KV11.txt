#1
Идеальная передача довольно полезна, потому что делает возможным программирование на более высоком уровне. 
Функции высшего порядка – это функции, которые могут принять другие функции в качестве аргументов или возвращать их.
Интересная реализация идеальной передачи:
template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args)
{
    return unique_ptr<T>(new T(std::forward<Args>(args)...));
}

#2
Тип T&&.
Универсальные ссылки — это параметры шаблонов функций.

#3
SFINAE - шаблон, который не может быть скомпилирован, не будет являться ошибкой, если существует подходящая
нешаблонная структура.

#4
Обычно enable_if используется для удаления кандидатов из разрешения перегрузки, 
т. е. функция отбраковывает набор перегрузки, чтобы одно определение было отброшено в пользу другого. 
Это соответствует поведению SFINAE.

#5
Правила вывода:
1) Шаблонную функцию:
template <typename T>
void f(T & arg) {}

Если запустим функцию от:	То T будет: 	arg будет иметь тип:

int				T = int		arg - int&
const int			T = const int	arg - const int &
const int &			T = const int	arg - const int &

2) Шаблонная функция:
template <typename T>
void f(T && arg) {}

Если запустим функцию от:	То T будет: 	arg будет иметь тип:

int				T = int&	arg - int& && = int&
const int			T = const int&	arg - const int &
const int &			T = const int&	arg - const int &
1				T = int		arg - int &&
std::move(x)			T = int &&	arg - int && && = int &&